name: App Pipeline (Build & Deploy Flask App)

on:
  push:
    paths:
      - "app/**"
      - ".github/workflows/app-pipeline.yml"
    branches:
      - main
  workflow_dispatch:

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: eu-north-1
  APP_DIR: app
  IMAGE_TAG: ${{ github.sha }}

jobs:
  build_and_deploy:
    runs-on: ubuntu-latest

    steps:
      ###################################
      # 1️⃣ Checkout Source Code
      ###################################
      - name: Checkout code
        uses: actions/checkout@v4

      ###################################
      # 2️⃣ Configure AWS OIDC Credentials
      ###################################
      - name: Configure AWS credentials via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-oidc-role
          aws-region: ${{ env.AWS_REGION }}

      ###################################
      # 3️⃣ Setup Terraform & Get Infrastructure Info
      ###################################
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.9.5

      - name: Get Infrastructure Information
        working-directory: infra
        run: |
          terraform init \
            -backend-config="bucket=terraform-github-actions-deploy-state-bucket" \
            -backend-config="key=infra/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}" \
            -backend-config="dynamodb_table=terraform-github-actions-deploy-locks"
          
          ECR_REPO_URL=$(terraform output -raw ecr_repository_url)
          EC2_PUBLIC_IP=$(terraform output -raw ec2_public_ip)
          SSH_PRIVATE_KEY=$(terraform output -raw ssh_private_key)
          
          echo "ECR_REPO_URL=$ECR_REPO_URL" >> $GITHUB_ENV
          echo "EC2_PUBLIC_IP=$EC2_PUBLIC_IP" >> $GITHUB_ENV
          echo "SSH_PRIVATE_KEY<<EOF" >> $GITHUB_ENV
          echo "$SSH_PRIVATE_KEY" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      ###################################
      # 4️⃣ Login to ECR
      ###################################
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      ###################################
      # 5️⃣ Build & Push Docker Image
      ###################################
      - name: Build, Tag, and Push Docker Image to ECR
        run: |
          echo "Building Docker image..."
          docker build -t $ECR_REPO_URL:${{ env.IMAGE_TAG }} ${{ env.APP_DIR }}
          echo "Pushing image to ECR..."
          docker push $ECR_REPO_URL:${{ env.IMAGE_TAG }}
          echo "✅ Image pushed successfully: $ECR_REPO_URL:${{ env.IMAGE_TAG }}"

      ###################################
      # 6️⃣ Deploy on EC2 via SSH
      ###################################
      - name: Deploy Flask App on EC2
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ env.EC2_PUBLIC_IP }}
          username: ubuntu
          key: ${{ env.SSH_PRIVATE_KEY }}
          script: |
            set -e
            echo "✅ Connected to EC2. Starting deployment..."
            
            # Install updates if not present
            if ! command -v aws &> /dev/null; then
              echo "Installing AWS CLI..."
              sudo apt-get update
              sudo apt-get install -y unzip curl
              curl "https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip" -o "awscliv2.zip"
              unzip awscliv2.zip
              sudo ./aws/install
            fi

            if ! systemctl is-active --quiet docker; then
              echo "Starting Docker..."
              sudo systemctl start docker
              sudo usermod -aG docker ubuntu
            fi

            # Authenticate to ECR
            echo "Logging into ECR..."
            aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REPO_URL }}

            # Pull latest image
            echo "Pulling latest Flask app image..."
            docker pull ${{ env.ECR_REPO_URL }}:${{ env.IMAGE_TAG }}

            # Stop and remove old container if exists
            docker stop flask_app || true
            docker rm flask_app || true

            # Run new container
            echo "Starting new Flask container..."
            docker run -d -p 8080:8080 --name flask_app --restart unless-stopped ${{ env.ECR_REPO_URL }}:${{ env.IMAGE_TAG }}

            echo "✅ Deployment successful! App running on port 8080"
